"""
Pydantic Schemas for Autonomous Agent

Defines the data structures for validating and parsing the agent's
LLM responses. Using Pydantic ensures that the agent's decisions
adhere to a strict, expected format, which is critical for
reliable tool execution and error handling.
"""

from pydantic import BaseModel, Field
from typing import Dict, Any, Optional, List, Literal
from datetime import datetime


class AgentDecision(BaseModel):
    """
    Schema for the agent's decision response.
    
    This Pydantic model validates the JSON object that the agent is expected
    to return. It ensures the response contains the necessary fields for
    the graph to decide the next action.
    """
    reasoning: str = Field(description="Brief explanation of why the agent chose this action")
    action: str = Field(description="The name of the tool to call, or 'generate_report' to finish")
    arguments: Optional[Dict[str, Any]] = Field(
        default={},
        description="The arguments to pass to the tool"
    )


# ============================================================================
# Portfolio Data Schemas
# ============================================================================


class PortfolioPosition(BaseModel):
    """
    Schema for a single portfolio position from Google Sheets.
    
    Attributes:
        symbol: Stock ticker symbol (e.g., 'AAPL')
        price: Current price per share
        position: Number of shares held
        market_value: Total value of position (price * position)
        percent_of_total: Position percentage of total portfolio (0-100)
    
    Examples:
        >>> pos = PortfolioPosition(
        ...     symbol="AAPL",
        ...     price=150.0,
        ...     position=100,
        ...     market_value=15000.0,
        ...     percent_of_total=10.0
        ... )
    """
    symbol: str = Field(description="Stock ticker symbol")
    price: float = Field(ge=0.0, description="Current price per share")
    position: int = Field(ge=0, description="Number of shares held")
    market_value: float = Field(ge=0.0, description="Total value of position")
    percent_of_total: float = Field(
        ge=0.0, 
        le=100.0, 
        description="Position percentage of total portfolio"
    )
    
    class Config:
        frozen = True


class Portfolio(BaseModel):
    """
    Schema for complete portfolio data from Google Sheets.
    
    Attributes:
        positions: List of portfolio positions
        total_value: Total portfolio value across all positions
    
    Examples:
        >>> portfolio = Portfolio(
        ...     positions=[
        ...         PortfolioPosition(symbol="AAPL", price=150.0, position=100, 
        ...                           market_value=15000.0, percent_of_total=50.0),
        ...         PortfolioPosition(symbol="MSFT", price=300.0, position=50,
        ...                           market_value=15000.0, percent_of_total=50.0)
        ...     ],
        ...     total_value=30000.0
        ... )
    """
    positions: List[PortfolioPosition] = Field(
        min_length=1,
        description="List of portfolio positions"
    )
    total_value: float = Field(
        ge=0.0,
        description="Total portfolio value"
    )
    
    class Config:
        frozen = True


# ============================================================================
# V3 Schemas - Supervisor Multi-Agent Architecture
# ============================================================================


class MarketRegime(BaseModel):
    """
    Market regime classification from Macro Agent.
    
    Attributes:
        status: Economic regime type based on inflation and growth
        signal: Risk appetite indicator (Risk-On = bullish, Risk-Off = bearish)
        key_driver: Primary factor influencing current regime
        confidence: Agent's confidence in classification (0.0 to 1.0)
    
    Examples:
        >>> regime = MarketRegime(
        ...     status="Inflationary",
        ...     signal="Risk-Off",
        ...     key_driver="Rising interest rates",
        ...     confidence=0.85
        ... )
    """
    status: Literal["Inflationary", "Deflationary", "Goldilocks"] = Field(
        description="Economic regime: Inflationary (high inflation), "
                    "Deflationary (recession risk), Goldilocks (balanced growth)"
    )
    signal: Literal["Risk-On", "Risk-Off"] = Field(
        description="Market risk appetite: Risk-On (bullish), Risk-Off (bearish)"
    )
    key_driver: str = Field(
        description="Primary macro factor (e.g., 'Rising rates', 'Inverted yield curve')"
    )
    confidence: float = Field(
        ge=0.0, 
        le=1.0, 
        description="Confidence score in classification"
    )
    
    class Config:
        frozen = True


class PositionAction(BaseModel):
    """
    Recommended action for a single portfolio position.
    
    Generated by Synthesis Node after combining sub-agent analyses
    (Fundamental, Technical, Macro, Risk).
    
    Attributes:
        ticker: Stock ticker symbol
        action: Recommended action (Buy/Sell/Hold)
        current_weight: Current portfolio weight (0.0 to 1.0)
        target_weight: Recommended portfolio weight (0.0 to 1.0)
        rationale: Explanation for recommendation
        confidence: Confidence in recommendation (0.0 to 1.0)
        fundamental_signal: Optional fundamental agent view
        technical_signal: Optional technical agent view
    
    Examples:
        >>> position = PositionAction(
        ...     ticker="AAPL",
        ...     action="Buy",
        ...     current_weight=0.10,
        ...     target_weight=0.15,
        ...     rationale="Strong fundamentals, bullish technicals",
        ...     confidence=0.75,
        ...     fundamental_signal="Undervalued (P/E: 20)",
        ...     technical_signal="Uptrend with RSI: 55"
        ... )
    """
    ticker: str = Field(description="Stock ticker symbol (e.g., 'AAPL')")
    action: Literal["Buy", "Sell", "Hold"] = Field(
        description="Recommended action"
    )
    current_weight: float = Field(
        ge=0.0, 
        le=1.0, 
        description="Current portfolio weight (e.g., 0.15 = 15%)"
    )
    target_weight: float = Field(
        ge=0.0, 
        le=1.0, 
        description="Recommended portfolio weight"
    )
    rationale: str = Field(
        min_length=10,
        description="Explanation for recommendation"
    )
    confidence: float = Field(
        ge=0.0, 
        le=1.0, 
        description="Confidence in recommendation"
    )
    
    # Sub-agent signals (for transparency)
    fundamental_signal: Optional[str] = Field(
        default=None, 
        description="Fundamental agent view (e.g., 'Undervalued')"
    )
    technical_signal: Optional[str] = Field(
        default=None, 
        description="Technical agent view (e.g., 'Uptrend')"
    )
    
    class Config:
        frozen = True


class PortfolioStrategy(BaseModel):
    """
    High-level portfolio strategy recommendation.
    
    Attributes:
        action: Strategic action to take
        rationale: Strategic reasoning
        priority: Urgency level of the strategy
    
    Examples:
        >>> strategy = PortfolioStrategy(
        ...     action="Reduce_Risk",
        ...     rationale="Market regime shifted to Risk-Off, reduce equity exposure",
        ...     priority="High"
        ... )
    """
    action: Literal["Rebalance", "Hold", "Accumulate", "Reduce_Risk"] = Field(
        description="Strategic action: Rebalance (adjust positions), "
                    "Hold (no changes), Accumulate (add cash to positions), "
                    "Reduce_Risk (increase defensive positions)"
    )
    rationale: str = Field(
        min_length=20,
        description="Strategic reasoning"
    )
    priority: Literal["High", "Medium", "Low"] = Field(
        default="Medium",
        description="Urgency level"
    )
    
    class Config:
        frozen = True


class RiskAssessment(BaseModel):
    """
    Portfolio risk metrics from Risk Agent.
    
    Calculated using historical returns and modern portfolio theory.
    All metrics use industry-standard formulas.
    
    Attributes:
        beta: Portfolio beta vs. S&P 500 (1.0 = moves with market)
        sharpe_ratio: Risk-adjusted return metric (higher is better)
        portfolio_volatility: Annualized standard deviation
        var_95: Value at Risk at 95% confidence (expected max loss)
        max_drawdown: Worst peak-to-trough decline (negative number)
        max_drawdown_risk: Risk classification based on max drawdown
        lookback_period: Historical period used for calculations
        calculation_date: When metrics were calculated
    
    Examples:
        >>> risk = RiskAssessment(
        ...     beta=1.2,
        ...     sharpe_ratio=1.5,
        ...     portfolio_volatility=0.18,
        ...     var_95=-0.05,
        ...     max_drawdown=-0.15,
        ...     max_drawdown_risk="Moderate",
        ...     lookback_period="1y",
        ...     calculation_date=datetime.now()
        ... )
    """
    # Core metrics
    beta: float = Field(
        description="Portfolio beta vs. S&P 500 (1.0 = market average, "
                    ">1.0 = more volatile, <1.0 = less volatile)"
    )
    sharpe_ratio: float = Field(
        description="Risk-adjusted return metric "
                    "(>1.0 = good, >2.0 = excellent, <0 = losing money)"
    )
    portfolio_volatility: float = Field(
        ge=0.0, 
        description="Annualized standard deviation (e.g., 0.18 = 18% volatility)"
    )
    
    # Risk measures
    var_95: float = Field(
        description="Value at Risk (95% confidence) - expected max loss in worst 5% of cases "
                    "(e.g., -0.05 = 5% loss)"
    )
    max_drawdown: float = Field(
        le=0.0, 
        description="Worst peak-to-trough decline (e.g., -0.20 = 20% decline)"
    )
    max_drawdown_risk: Literal["Low", "Moderate", "High"] = Field(
        description="Risk classification: Low (< -10%), Moderate (< -20%), High (>= -20%)"
    )
    
    # Context
    lookback_period: str = Field(
        default="1y", 
        description="Historical period used (e.g., '1y', '252 days')"
    )
    calculation_date: datetime = Field(
        description="When metrics were calculated"
    )
    
    class Config:
        frozen = True


class PortfolioReport(BaseModel):
    """
    Complete portfolio analysis report (V3 structured output).
    
    This is the final output schema that the supervisor generates
    after all sub-agents complete their analyses. It combines
    insights from Macro, Fundamental, Technical, and Risk agents.
    
    Attributes:
        executive_summary: High-level overview for user
        market_regime: Macro Agent's market regime analysis
        portfolio_strategy: Overall strategy recommendation
        positions: Per-position recommendations
        risk_assessment: Portfolio risk metrics
        reflexion_notes: Self-critique and confidence qualifiers
        timestamp: Report generation timestamp
        confidence_score: Overall confidence in analysis
        agent_version: Agent version identifier
        disclaimer: Legal/compliance disclaimer
    
    Examples:
        >>> report = PortfolioReport(
        ...     executive_summary="Market in Risk-Off mode...",
        ...     market_regime=MarketRegime(...),
        ...     portfolio_strategy=PortfolioStrategy(...),
        ...     positions=[PositionAction(...), PositionAction(...)],
        ...     risk_assessment=RiskAssessment(...),
        ...     reflexion_notes="High confidence, no biases detected",
        ...     confidence_score=0.80
        ... )
        >>> report_dict = report.to_dict()
    """
    # Summary
    executive_summary: str = Field(
        min_length=50,
        description="High-level overview for user (2-3 paragraphs)"
    )
    
    # Sub-agent outputs
    market_regime: MarketRegime = Field(
        description="Macro Agent's market regime analysis"
    )
    portfolio_strategy: PortfolioStrategy = Field(
        description="Overall strategy recommendation"
    )
    positions: List[PositionAction] = Field(
        min_length=1,
        description="Per-position recommendations"
    )
    risk_assessment: RiskAssessment = Field(
        description="Portfolio risk metrics"
    )
    
    # Reflexion
    reflexion_notes: str = Field(
        min_length=20,
        description="Self-critique and confidence qualifiers from Reflexion Node"
    )
    
    # Metadata
    timestamp: datetime = Field(
        default_factory=datetime.now,
        description="Report generation timestamp"
    )
    confidence_score: float = Field(
        ge=0.0, 
        le=1.0, 
        description="Overall confidence in analysis (0.0 to 1.0)"
    )
    agent_version: str = Field(
        default="v3.0",
        description="Agent version identifier"
    )
    
    # Compliance
    disclaimer: str = Field(
        default="I am an AI assistant. This is not financial advice. "
                "Consult a licensed financial advisor before making investment decisions.",
        description="Legal/compliance disclaimer"
    )
    
    def to_dict(self) -> Dict:
        """
        Convert report to dictionary for JSON serialization.
        
        Returns:
            Dictionary representation suitable for JSON output
            
        Examples:
            >>> report = PortfolioReport(...)
            >>> json_dict = report.to_dict()
            >>> import json
            >>> json_str = json.dumps(json_dict, indent=2)
        """
        return self.model_dump(mode='json')
    
    class Config:
        frozen = True


# ============================================================================
# Phase 3 Schemas - Supervisor Orchestration & Reflexion
# ============================================================================


class ExecutionPlan(BaseModel):
    """
    Supervisor's decomposed execution plan for multi-agent coordination.
    
    Defines which sub-agents to invoke, in what order, and which tasks
    can be executed in parallel.
    
    Attributes:
        tasks: Ordered list of sub-agent tasks to execute
        parallel_groups: Groups of tasks that can run in parallel
        rationale: Brief explanation of the planning strategy
    
    Examples:
        >>> plan = ExecutionPlan(
        ...     tasks=[
        ...         "Invoke Macro Agent",
        ...         "Invoke Fundamental Agent (batch)",
        ...         "Invoke Technical Agent (batch)",
        ...         "Invoke Risk Agent"
        ...     ],
        ...     parallel_groups=[["Fundamental Agent", "Technical Agent"]],
        ...     rationale="Macro first for context, then parallel ticker analysis, then risk"
        ... )
    """
    tasks: List[str] = Field(
        min_length=1,
        description="Ordered list of sub-agent tasks (e.g., 'Invoke Macro Agent')"
    )
    parallel_groups: List[List[str]] = Field(
        default_factory=list,
        description="Groups of tasks that can run in parallel (e.g., [['Fundamental', 'Technical']])"
    )
    rationale: str = Field(
        min_length=20,
        description="Planning rationale explaining execution strategy"
    )
    
    class Config:
        frozen = True


class ConflictResolution(BaseModel):
    """
    Record of how conflicts between sub-agents were resolved.
    
    Tracks divergences between sub-agent recommendations (e.g., Fundamental
    says "Buy" but Technical says "Sell") and documents how the conflict
    was resolved by the Synthesis Node.
    
    Attributes:
        conflict_type: Type/description of conflict
        conflicting_signals: What each agent recommended (keyed by agent name)
        resolution: How the conflict was resolved
        rationale: Justification for the resolution approach
    
    Examples:
        >>> conflict = ConflictResolution(
        ...     conflict_type="Fundamental vs. Technical (AAPL)",
        ...     conflicting_signals={
        ...         "Fundamental": "Buy (undervalued, P/E=18)",
        ...         "Technical": "Sell (downtrend, RSI=35)"
        ...     },
        ...     resolution="Weighted to Hold based on long-term horizon",
        ...     rationale="Long-term fundamentals weighted 60% vs. short-term technicals 30%"
        ... )
    """
    conflict_type: str = Field(
        min_length=5,
        description="Type of conflict (e.g., 'Fundamental vs. Technical (AAPL)')"
    )
    conflicting_signals: Dict[str, str] = Field(
        description="What each agent recommended (e.g., {'Fundamental': 'Buy', 'Technical': 'Sell'})"
    )
    resolution: str = Field(
        min_length=10,
        description="How conflict was resolved (e.g., 'Weighted to Hold')"
    )
    rationale: str = Field(
        min_length=20,
        description="Justification for resolution approach"
    )
    
    class Config:
        frozen = True


class ReflexionCritique(BaseModel):
    """
    Self-critique from Reflexion Node applying "Risk Officer" review.
    
    After synthesis generates recommendations, the Reflexion Node assumes
    a "Senior Risk Officer" persona to critique the analysis for biases,
    errors, and inconsistencies. This enables self-correction before
    finalizing recommendations.
    
    Attributes:
        approved: Whether synthesis is approved (True) or rejected (False)
        issues_found: List of specific issues identified (empty if approved)
        suggestions: Actionable suggestions for improvement
        confidence_adjustment: Confidence adjustment factor (-0.3 to +0.3)
    
    Examples:
        >>> critique = ReflexionCritique(
        ...     approved=False,
        ...     issues_found=[
        ...         "Macro Risk-Off signal ignored in Buy recommendations",
        ...         "High portfolio risk (Beta=1.5) but recommending more buys"
        ...     ],
        ...     suggestions=[
        ...         "Downgrade Buy signals to Hold given Risk-Off macro",
        ...         "Recommend rebalancing before accumulating"
        ...     ],
        ...     confidence_adjustment=-0.2
        ... )
    """
    approved: bool = Field(
        description="Whether synthesis is approved (True) or needs revision (False)"
    )
    issues_found: List[str] = Field(
        default_factory=list,
        description="Specific issues identified (empty list if approved)"
    )
    suggestions: List[str] = Field(
        default_factory=list,
        description="Actionable suggestions for improvement (empty if approved)"
    )
    confidence_adjustment: float = Field(
        ge=-0.3,
        le=0.3,
        default=0.0,
        description="Confidence adjustment factor (-0.3 = reduce, +0.3 = increase)"
    )
    
    class Config:
        frozen = True

